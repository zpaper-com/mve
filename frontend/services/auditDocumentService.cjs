const fs = require('fs');
const path = require('path');
const { PDFDocument, StandardFonts, rgb } = require('pdf-lib');

class AuditDocumentService {
  constructor() {
    this.outputDir = path.join(__dirname, '../audit_documents');
    this.ensureOutputDirectory();
  }

  ensureOutputDirectory() {
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true });
    }
  }

  /**
   * Generate audit document PDF for a completed workflow
   * @param {Object} workflowData - Complete workflow data with recipients and form data
   * @param {string} workflowId - Workflow ID for filename
   * @returns {Promise<string>} Path to the generated audit PDF
   */
  async generateAuditDocument(workflowData, workflowId) {
    try {
      console.log('📋 Starting audit document generation for workflow:', workflowId);
      
      // Create a new PDF document
      const pdfDoc = await PDFDocument.create();
      let page = pdfDoc.addPage([612, 792]); // Standard letter size
      
      // Load fonts
      const titleFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
      const headingFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
      const bodyFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
      const monoFont = await pdfDoc.embedFont(StandardFonts.CourierBold);
      
      const { width, height } = page.getSize();
      let yPosition = height - 50;
      
      // Title
      page.drawText('WORKFLOW AUDIT DOCUMENT', {
        x: 50,
        y: yPosition,
        size: 20,
        font: titleFont,
        color: rgb(0, 0, 0),
      });
      yPosition -= 30;
      
      // Sprkz branding
      page.drawText('Generated by Sprkz PDF Workflow System', {
        x: 50,
        y: yPosition,
        size: 10,
        font: bodyFont,
        color: rgb(0.5, 0.5, 0.5),
      });
      yPosition -= 40;
      
      // Workflow Information Section
      yPosition = this.addSection(page, 'WORKFLOW INFORMATION', yPosition, headingFont, bodyFont);
      yPosition -= 15;
      
      const workflowInfo = [
        ['Workflow ID:', workflowData.id],
        ['UUID:', workflowData.uuid],
        ['Status:', workflowData.status.toUpperCase()],
        ['Document URL:', workflowData.document_url],
        ['Created:', new Date(workflowData.created_at).toLocaleString()],
        ['Completed:', workflowData.updated_at ? new Date(workflowData.updated_at).toLocaleString() : 'N/A'],
        ['Completed PDF:', workflowData.completed_pdf_path ? 'Generated' : 'Not Available']
      ];
      
      for (const [label, value] of workflowInfo) {
        yPosition = this.addKeyValue(page, label, value, yPosition, bodyFont, monoFont);
        yPosition -= 12;
      }
      
      yPosition -= 10;
      
      // Recipients Section
      yPosition = this.addSection(page, 'WORKFLOW PARTICIPANTS', yPosition, headingFont, bodyFont);
      yPosition -= 20;
      
      // Recipients table header
      this.drawTableHeader(page, yPosition, headingFont);
      yPosition -= 20;
      
      // Recipients data
      const recipients = workflowData.formDataHistory || [];
      for (let i = 0; i < recipients.length; i++) {
        const recipient = recipients[i];
        
        // Check if we need a new page
        if (yPosition < 100) {
          page = pdfDoc.addPage([612, 792]);
          yPosition = height - 50;
        }
        
        this.drawTableRow(page, yPosition, recipient, i + 1, bodyFont);
        yPosition -= 15;
      }
      
      yPosition -= 20;
      
      // Form Data Summary Section
      if (recipients.length > 0) {
        yPosition = this.addSection(page, 'FORM DATA SUMMARY', yPosition, headingFont, bodyFont);
        yPosition -= 15;
        
        let totalFields = 0;
        const fieldsSummary = {};
        
        recipients.forEach(recipient => {
          if (recipient.form_data && typeof recipient.form_data === 'object') {
            const fields = Object.keys(recipient.form_data);
            totalFields += fields.length;
            fieldsSummary[recipient.recipient_name] = fields.length;
          }
        });
        
        yPosition = this.addKeyValue(page, 'Total Form Fields:', totalFields.toString(), yPosition, bodyFont, monoFont);
        yPosition -= 12;
        
        for (const [recipientName, fieldCount] of Object.entries(fieldsSummary)) {
          yPosition = this.addKeyValue(page, `${recipientName}:`, `${fieldCount} fields`, yPosition, bodyFont, monoFont);
          yPosition -= 12;
        }
      }
      
      yPosition -= 20;
      
      // Attachments Section (if any)
      if (workflowData.attachments && workflowData.attachments.length > 0) {
        yPosition = this.addSection(page, 'ATTACHMENTS', yPosition, headingFont, bodyFont);
        yPosition -= 15;
        
        workflowData.attachments.forEach(attachment => {
          const attachmentInfo = `${attachment.original_filename} (${this.formatFileSize(attachment.file_size)}) - ${attachment.uploaded_by}`;
          yPosition = this.addKeyValue(page, 'File:', attachmentInfo, yPosition, bodyFont, monoFont);
          yPosition -= 12;
        });
      }
      
      yPosition -= 20;
      
      // Digital Signatures Section
      console.log('📝 About to extract signature data from formDataHistory:', workflowData.formDataHistory ? workflowData.formDataHistory.length : 'undefined');
      const signatureData = this.extractSignatureData(workflowData.formDataHistory || []);
      console.log('📝 Signature extraction completed, found:', signatureData.length, 'signatures');
      if (signatureData.length > 0) {
        // Check if we need a new page for signatures
        if (yPosition < 200) {
          page = pdfDoc.addPage([612, 792]);
          yPosition = height - 50;
        }
        
        yPosition = this.addSection(page, 'DIGITAL SIGNATURES', yPosition, headingFont, bodyFont);
        yPosition -= 20;
        
        for (const sigData of signatureData) {
          // Check if we need a new page for this signature
          if (yPosition < 150) {
            page = pdfDoc.addPage([612, 792]);
            yPosition = height - 50;
          }
          
          yPosition = await this.addSignatureToAudit(page, pdfDoc, sigData, yPosition, headingFont, bodyFont, monoFont);
          yPosition -= 30;
        }
      }
      
      yPosition -= 30;
      
      // Footer
      page.drawText('This document was automatically generated by the Sprkz PDF Workflow System.', {
        x: 50,
        y: 50,
        size: 8,
        font: bodyFont,
        color: rgb(0.7, 0.7, 0.7),
      });
      
      page.drawText(`Generated on: ${new Date().toLocaleString()}`, {
        x: 50,
        y: 35,
        size: 8,
        font: bodyFont,
        color: rgb(0.7, 0.7, 0.7),
      });
      
      // Save the audit PDF
      const outputFilename = `workflow_${workflowId}_audit.pdf`;
      const outputPath = path.join(this.outputDir, outputFilename);
      
      const pdfBytes = await pdfDoc.save();
      fs.writeFileSync(outputPath, pdfBytes);
      
      console.log('✅ Audit document generated:', outputPath);
      
      return outputPath;
    } catch (error) {
      console.error('❌ Error generating audit document:', error);
      throw error;
    }
  }
  
  addSection(page, title, yPosition, headingFont, bodyFont) {
    // Add section separator line
    page.drawLine({
      start: { x: 50, y: yPosition + 5 },
      end: { x: 562, y: yPosition + 5 },
      thickness: 1,
      color: rgb(0.8, 0.8, 0.8),
    });
    
    page.drawText(title, {
      x: 50,
      y: yPosition - 15,
      size: 14,
      font: headingFont,
      color: rgb(0.2, 0.2, 0.2),
    });
    
    return yPosition - 25;
  }
  
  addKeyValue(page, key, value, yPosition, bodyFont, monoFont) {
    page.drawText(key, {
      x: 70,
      y: yPosition,
      size: 10,
      font: bodyFont,
      color: rgb(0.3, 0.3, 0.3),
    });
    
    // Truncate long values
    const truncatedValue = value.length > 80 ? value.substring(0, 77) + '...' : value;
    
    page.drawText(truncatedValue, {
      x: 200,
      y: yPosition,
      size: 10,
      font: monoFont,
      color: rgb(0, 0, 0),
    });
    
    return yPosition;
  }
  
  drawTableHeader(page, yPosition, headingFont) {
    const headers = ['#', 'Participant Name', 'Type', 'Status', 'Completed'];
    const positions = [70, 120, 250, 350, 450];
    
    // Draw header background
    page.drawRectangle({
      x: 60,
      y: yPosition - 5,
      width: 502,
      height: 18,
      color: rgb(0.95, 0.95, 0.95),
    });
    
    headers.forEach((header, index) => {
      page.drawText(header, {
        x: positions[index],
        y: yPosition,
        size: 10,
        font: headingFont,
        color: rgb(0, 0, 0),
      });
    });
  }
  
  drawTableRow(page, yPosition, recipient, index, bodyFont) {
    const values = [
      index.toString(),
      recipient.recipient_name || 'N/A',
      recipient.recipient_type || 'N/A',
      recipient.status || 'pending',
      recipient.submitted_at ? new Date(recipient.submitted_at).toLocaleDateString() : 'N/A'
    ];
    const positions = [70, 120, 250, 350, 450];
    
    // Alternate row background
    if (index % 2 === 0) {
      page.drawRectangle({
        x: 60,
        y: yPosition - 5,
        width: 502,
        height: 15,
        color: rgb(0.98, 0.98, 0.98),
      });
    }
    
    values.forEach((value, idx) => {
      page.drawText(value, {
        x: positions[idx],
        y: yPosition,
        size: 9,
        font: bodyFont,
        color: rgb(0, 0, 0),
      });
    });
  }
  
  formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
  
  getRelativePath(fullPath) {
    return fullPath.replace(__dirname.replace('/services', ''), '');
  }
  
  /**
   * Extract signature data from recipients
   * @param {Array} recipients - Array of recipient data with form_data
   * @returns {Array} Array of signature objects
   */
  extractSignatureData(recipients) {
    const signatures = [];
    
    console.log(`🔍 Extracting signatures from ${recipients.length} recipients`);
    
    recipients.forEach(recipient => {
      console.log(`   → Checking recipient: ${recipient.recipient_name}`);
      if (recipient.form_data && typeof recipient.form_data === 'object') {
        const fieldNames = Object.keys(recipient.form_data);
        console.log(`     → Found ${fieldNames.length} form fields:`, fieldNames.slice(0, 5));
        
        // Look for signature fields in form data
        Object.entries(recipient.form_data).forEach(([fieldName, value]) => {
          const isSignatureField = (fieldName.toLowerCase().includes('sign') || 
                                   fieldName.toLowerCase().includes('auth'));
          const isImageData = typeof value === 'string' && value.startsWith('data:image/');
          
          if (isSignatureField) {
            console.log(`     → Found signature field: ${fieldName}, isImageData: ${isImageData}, valueLength: ${typeof value === 'string' ? value.length : 'N/A'}`);
          }
          
          if (isImageData && isSignatureField) {
            console.log(`     ✅ Valid signature found: ${fieldName}`);
            
            // Look for corresponding metadata
            const metadataKey = `${fieldName}_metadata`;
            let metadata = null;
            if (recipient.form_data[metadataKey]) {
              try {
                metadata = JSON.parse(recipient.form_data[metadataKey]);
                console.log(`     → Metadata found:`, metadata);
              } catch (e) {
                console.warn('Failed to parse signature metadata:', e);
              }
            }
            
            signatures.push({
              recipientName: recipient.recipient_name,
              recipientType: recipient.recipient_type,
              fieldName: fieldName,
              signatureData: value,
              metadata: metadata,
              submittedAt: recipient.submitted_at
            });
          }
        });
      } else {
        console.log(`     → No form data for ${recipient.recipient_name}`);
      }
    });
    
    console.log(`🔍 Total signatures extracted: ${signatures.length}`);
    return signatures;
  }
  
  /**
   * Add a signature section to the audit PDF
   * @param {PDFPage} page - PDF page to draw on
   * @param {PDFDocument} pdfDoc - PDF document
   * @param {Object} sigData - Signature data object
   * @param {number} yPosition - Current Y position
   * @param {PDFFont} headingFont - Heading font
   * @param {PDFFont} bodyFont - Body font
   * @param {PDFFont} monoFont - Monospace font
   * @returns {Promise<number>} New Y position
   */
  async addSignatureToAudit(page, pdfDoc, sigData, yPosition, headingFont, bodyFont, monoFont) {
    try {
      // Signature header
      page.drawText(`${sigData.recipientName} (${sigData.recipientType})`, {
        x: 70,
        y: yPosition,
        size: 12,
        font: headingFont,
        color: rgb(0.2, 0.2, 0.2),
      });
      yPosition -= 20;
      
      // Field name
      yPosition = this.addKeyValue(page, 'Field:', sigData.fieldName, yPosition, bodyFont, monoFont);
      yPosition -= 12;
      
      // Signature metadata
      if (sigData.metadata) {
        if (sigData.metadata.signedAt) {
          const signedDate = new Date(sigData.metadata.signedAt).toLocaleString();
          yPosition = this.addKeyValue(page, 'Signed At:', signedDate, yPosition, bodyFont, monoFont);
          yPosition -= 12;
        }
        
        if (sigData.metadata.signedIP) {
          yPosition = this.addKeyValue(page, 'IP Address:', sigData.metadata.signedIP, yPosition, bodyFont, monoFont);
          yPosition -= 12;
        }
      }
      
      // Submitted date fallback
      if (sigData.submittedAt && !sigData.metadata?.signedAt) {
        const submittedDate = new Date(sigData.submittedAt).toLocaleString();
        yPosition = this.addKeyValue(page, 'Submitted At:', submittedDate, yPosition, bodyFont, monoFont);
        yPosition -= 12;
      }
      
      yPosition -= 10;
      
      // Embed the signature image
      try {
        // Convert base64 to buffer
        const base64Data = sigData.signatureData.split(',')[1];
        const imageBytes = Buffer.from(base64Data, 'base64');
        
        // Determine image type and embed
        let image;
        if (sigData.signatureData.startsWith('data:image/png')) {
          image = await pdfDoc.embedPng(imageBytes);
        } else if (sigData.signatureData.startsWith('data:image/jpeg') || 
                   sigData.signatureData.startsWith('data:image/jpg')) {
          image = await pdfDoc.embedJpg(imageBytes);
        } else {
          throw new Error('Unsupported image format');
        }
        
        // Calculate dimensions (max width 200px, maintain aspect ratio)
        const maxWidth = 200;
        const maxHeight = 80;
        const { width: imgWidth, height: imgHeight } = image.scale(1);
        
        let drawWidth = Math.min(maxWidth, imgWidth);
        let drawHeight = (drawWidth / imgWidth) * imgHeight;
        
        if (drawHeight > maxHeight) {
          drawHeight = maxHeight;
          drawWidth = (drawHeight / imgHeight) * imgWidth;
        }
        
        // Draw signature border
        page.drawRectangle({
          x: 69,
          y: yPosition - drawHeight - 5,
          width: drawWidth + 2,
          height: drawHeight + 2,
          borderColor: rgb(0.8, 0.8, 0.8),
          borderWidth: 1,
        });
        
        // Draw the signature image
        page.drawImage(image, {
          x: 70,
          y: yPosition - drawHeight - 4,
          width: drawWidth,
          height: drawHeight,
        });
        
        yPosition -= (drawHeight + 15);
        
      } catch (error) {
        console.warn('Failed to embed signature image:', error);
        page.drawText('Signature image could not be embedded', {
          x: 70,
          y: yPosition,
          size: 10,
          font: bodyFont,
          color: rgb(0.7, 0.7, 0.7),
        });
        yPosition -= 15;
      }
      
      // Add separator line
      page.drawLine({
        start: { x: 50, y: yPosition },
        end: { x: 562, y: yPosition },
        thickness: 0.5,
        color: rgb(0.9, 0.9, 0.9),
      });
      
      return yPosition;
    } catch (error) {
      console.error('Error adding signature to audit:', error);
      return yPosition - 20;
    }
  }
}

module.exports = AuditDocumentService;